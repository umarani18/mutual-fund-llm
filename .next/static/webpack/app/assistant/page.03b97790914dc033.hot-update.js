"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/assistant/page",{

/***/ "(app-pages-browser)/./hooks/useChat.js":
/*!**************************!*\
  !*** ./hooks/useChat.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.js\");\n/* __next_internal_client_entry_do_not_use__ useChat auto */ var _s = $RefreshSig$();\n\n\nconst useChat = ()=>{\n    _s();\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [historyLoading, setHistoryLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [currentChatId, setCurrentChatId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [chatList, setChatList] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const messagesEndRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const scrollToBottom = ()=>{\n        var _messagesEndRef_current;\n        (_messagesEndRef_current = messagesEndRef.current) === null || _messagesEndRef_current === void 0 ? void 0 : _messagesEndRef_current.scrollIntoView({\n            behavior: \"smooth\"\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        scrollToBottom();\n    }, [\n        messages,\n        loading\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        loadChatHistory();\n    }, []);\n    // Auto-restore removed to force new session on refresh\n    const loadChatHistory = async ()=>{\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.getHistory();\n            if (data.status === \"success\") {\n                setChatList(data.chats);\n            }\n        } catch (err) {\n            console.error(\"Failed to load chat history:\", err);\n        }\n    };\n    const startNewChat = async function() {\n        let title = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"New Chat\";\n        try {\n            setLoading(true);\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.createChat(title);\n            if (data.status === \"success\") {\n                setCurrentChatId(data.chat.Timestamp);\n                setMessages([]);\n                setChatList((prev)=>[\n                        data.chat,\n                        ...prev\n                    ]);\n            }\n        } catch (err) {\n            setError(\"Failed to create new chat\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const loadChat = async (timestamp)=>{\n        try {\n            setHistoryLoading(true);\n            setCurrentChatId(timestamp);\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.getChatMessages(timestamp);\n            if (data.status === \"success\") {\n                setMessages(data.chat.messages || []);\n            }\n        } catch (err) {\n            setError(\"Failed to load chat messages\");\n        } finally{\n            setHistoryLoading(false);\n        }\n    };\n    const deleteChat = async (timestamp)=>{\n        if (!window.confirm(\"Delete this specific chat session?\")) return;\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.deleteChat(timestamp);\n            setChatList((prev)=>prev.filter((c)=>c.Timestamp !== timestamp));\n            if (currentChatId === timestamp) {\n                setCurrentChatId(null);\n                setMessages([]);\n            }\n        } catch (err) {\n            console.error(\"Failed to delete chat:\", err);\n            setError(\"Failed to delete chat\");\n        }\n    };\n    const clearAllHistory = async ()=>{\n        if (!window.confirm(\"Are you sure you want to delete your entire chat history? This cannot be undone.\")) {\n            return;\n        }\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.deleteAllHistory();\n            setChatList([]);\n            setCurrentChatId(null);\n            setMessages([]);\n        } catch (err) {\n            console.error(\"Failed to clear ALL history:\", err);\n            setError(\"Failed to clear entire history\");\n        }\n    };\n    const sendMessage = async (prompt)=>{\n        if (!prompt.trim() || loading) return;\n        const userPrompt = prompt.trim();\n        setError(\"\");\n        const newUserMessage = {\n            role: \"user\",\n            content: userPrompt\n        };\n        setMessages((prev)=>[\n                ...prev,\n                newUserMessage\n            ]);\n        setLoading(true);\n        try {\n            let chatId = currentChatId;\n            // If no active chat, create one automatically\n            if (!chatId) {\n                const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.createChat(userPrompt.substring(0, 30) + \"...\");\n                if (data.status === \"success\") {\n                    chatId = data.chat.Timestamp;\n                    setCurrentChatId(chatId);\n                    setChatList((prev)=>{\n                        // Avoid duplicates\n                        if (prev.some((c)=>c.Timestamp === chatId)) return prev;\n                        return [\n                            data.chat,\n                            ...prev\n                        ];\n                    });\n                }\n            }\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.sendMessage(userPrompt, chatId);\n            if (data.status === \"success\") {\n                const aiMessage = {\n                    role: \"assistant\",\n                    content: data.chat_response || \"I've analyzed your requirements and found some great options for you.\",\n                    recommendations: data.recommendations || []\n                };\n                setMessages((prev)=>[\n                        ...prev,\n                        aiMessage\n                    ]);\n            } else {\n                setError(data.detail || \"Failed to generate recommendations\");\n                setMessages((prev)=>[\n                        ...prev,\n                        {\n                            role: \"assistant\",\n                            content: \"Sorry, I encountered an error while processing your request. Please try again.\"\n                        }\n                    ]);\n            }\n        } catch (err) {\n            setError(err.message || \"Error connecting to backend. Please try again.\");\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        role: \"assistant\",\n                        content: err.message || \"Connection failed\"\n                    }\n                ]);\n            console.error(\"Chat Error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const clearChat = ()=>{\n        setMessages([]);\n        setError(\"\");\n    };\n    // Persistence removed to ensure refresh starts new session\n    return {\n        messages,\n        loading,\n        historyLoading,\n        error,\n        chatList,\n        currentChatId,\n        sendMessage,\n        clearChat,\n        startNewChat,\n        loadChat,\n        deleteChat,\n        clearAllHistory,\n        messagesEndRef\n    };\n};\n_s(useChat, \"0epN0hDumMLKe4N5ju5ecN+3htY=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUNoYXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFb0Q7QUFDaEI7QUFFN0IsTUFBTUksVUFBVTs7SUFDbkIsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdOLCtDQUFRQSxDQUFDLEVBQUU7SUFDM0MsTUFBTSxDQUFDTyxTQUFTQyxXQUFXLEdBQUdSLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ1MsZ0JBQWdCQyxrQkFBa0IsR0FBR1YsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDVyxPQUFPQyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ2EsZUFBZUMsaUJBQWlCLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ2UsVUFBVUMsWUFBWSxHQUFHaEIsK0NBQVFBLENBQUMsRUFBRTtJQUMzQyxNQUFNaUIsaUJBQWlCaEIsNkNBQU1BLENBQUM7SUFFOUIsTUFBTWlCLGlCQUFpQjtZQUNuQkQ7U0FBQUEsMEJBQUFBLGVBQWVFLE9BQU8sY0FBdEJGLDhDQUFBQSx3QkFBd0JHLGNBQWMsQ0FBQztZQUFFQyxVQUFVO1FBQVM7SUFDaEU7SUFFQW5CLGdEQUFTQSxDQUFDO1FBQ05nQjtJQUNKLEdBQUc7UUFBQ2I7UUFBVUU7S0FBUTtJQUV0QkwsZ0RBQVNBLENBQUM7UUFDTm9CO0lBQ0osR0FBRyxFQUFFO0lBRUwsdURBQXVEO0lBR3ZELE1BQU1BLGtCQUFrQjtRQUNwQixJQUFJO1lBQ0EsTUFBTUMsT0FBTyxNQUFNcEIsNkNBQU9BLENBQUNxQixVQUFVO1lBQ3JDLElBQUlELEtBQUtFLE1BQU0sS0FBSyxXQUFXO2dCQUMzQlQsWUFBWU8sS0FBS0csS0FBSztZQUMxQjtRQUNKLEVBQUUsT0FBT0MsS0FBSztZQUNWQyxRQUFRakIsS0FBSyxDQUFDLGdDQUFnQ2dCO1FBQ2xEO0lBQ0o7SUFFQSxNQUFNRSxlQUFlO1lBQU9DLHlFQUFRO1FBQ2hDLElBQUk7WUFDQXRCLFdBQVc7WUFDWCxNQUFNZSxPQUFPLE1BQU1wQiw2Q0FBT0EsQ0FBQzRCLFVBQVUsQ0FBQ0Q7WUFDdEMsSUFBSVAsS0FBS0UsTUFBTSxLQUFLLFdBQVc7Z0JBQzNCWCxpQkFBaUJTLEtBQUtTLElBQUksQ0FBQ0MsU0FBUztnQkFDcEMzQixZQUFZLEVBQUU7Z0JBQ2RVLFlBQVlrQixDQUFBQSxPQUFRO3dCQUFDWCxLQUFLUyxJQUFJOzJCQUFLRTtxQkFBSztZQUM1QztRQUNKLEVBQUUsT0FBT1AsS0FBSztZQUNWZixTQUFTO1FBQ2IsU0FBVTtZQUNOSixXQUFXO1FBQ2Y7SUFDSjtJQUVBLE1BQU0yQixXQUFXLE9BQU9DO1FBQ3BCLElBQUk7WUFDQTFCLGtCQUFrQjtZQUNsQkksaUJBQWlCc0I7WUFDakIsTUFBTWIsT0FBTyxNQUFNcEIsNkNBQU9BLENBQUNrQyxlQUFlLENBQUNEO1lBQzNDLElBQUliLEtBQUtFLE1BQU0sS0FBSyxXQUFXO2dCQUMzQm5CLFlBQVlpQixLQUFLUyxJQUFJLENBQUMzQixRQUFRLElBQUksRUFBRTtZQUN4QztRQUNKLEVBQUUsT0FBT3NCLEtBQUs7WUFDVmYsU0FBUztRQUNiLFNBQVU7WUFDTkYsa0JBQWtCO1FBQ3RCO0lBQ0o7SUFFQSxNQUFNNEIsYUFBYSxPQUFPRjtRQUN0QixJQUFJLENBQUNHLE9BQU9DLE9BQU8sQ0FBQyx1Q0FBdUM7UUFFM0QsSUFBSTtZQUNBLE1BQU1yQyw2Q0FBT0EsQ0FBQ21DLFVBQVUsQ0FBQ0Y7WUFDekJwQixZQUFZa0IsQ0FBQUEsT0FBUUEsS0FBS08sTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFVCxTQUFTLEtBQUtHO1lBQ3JELElBQUl2QixrQkFBa0J1QixXQUFXO2dCQUM3QnRCLGlCQUFpQjtnQkFDakJSLFlBQVksRUFBRTtZQUNsQjtRQUNKLEVBQUUsT0FBT3FCLEtBQUs7WUFDVkMsUUFBUWpCLEtBQUssQ0FBQywwQkFBMEJnQjtZQUN4Q2YsU0FBUztRQUNiO0lBQ0o7SUFFQSxNQUFNK0Isa0JBQWtCO1FBQ3BCLElBQUksQ0FBQ0osT0FBT0MsT0FBTyxDQUFDLHFGQUFxRjtZQUNyRztRQUNKO1FBQ0EsSUFBSTtZQUNBLE1BQU1yQyw2Q0FBT0EsQ0FBQ3lDLGdCQUFnQjtZQUM5QjVCLFlBQVksRUFBRTtZQUNkRixpQkFBaUI7WUFDakJSLFlBQVksRUFBRTtRQUNsQixFQUFFLE9BQU9xQixLQUFLO1lBQ1ZDLFFBQVFqQixLQUFLLENBQUMsZ0NBQWdDZ0I7WUFDOUNmLFNBQVM7UUFDYjtJQUNKO0lBRUEsTUFBTWlDLGNBQWMsT0FBT0M7UUFDdkIsSUFBSSxDQUFDQSxPQUFPQyxJQUFJLE1BQU14QyxTQUFTO1FBRS9CLE1BQU15QyxhQUFhRixPQUFPQyxJQUFJO1FBQzlCbkMsU0FBUztRQUVULE1BQU1xQyxpQkFBaUI7WUFBRUMsTUFBTTtZQUFRQyxTQUFTSDtRQUFXO1FBQzNEMUMsWUFBWTRCLENBQUFBLE9BQVE7bUJBQUlBO2dCQUFNZTthQUFlO1FBQzdDekMsV0FBVztRQUVYLElBQUk7WUFDQSxJQUFJNEMsU0FBU3ZDO1lBQ2IsOENBQThDO1lBQzlDLElBQUksQ0FBQ3VDLFFBQVE7Z0JBQ1QsTUFBTTdCLE9BQU8sTUFBTXBCLDZDQUFPQSxDQUFDNEIsVUFBVSxDQUFDaUIsV0FBV0ssU0FBUyxDQUFDLEdBQUcsTUFBTTtnQkFDcEUsSUFBSTlCLEtBQUtFLE1BQU0sS0FBSyxXQUFXO29CQUMzQjJCLFNBQVM3QixLQUFLUyxJQUFJLENBQUNDLFNBQVM7b0JBQzVCbkIsaUJBQWlCc0M7b0JBQ2pCcEMsWUFBWWtCLENBQUFBO3dCQUNSLG1CQUFtQjt3QkFDbkIsSUFBSUEsS0FBS29CLElBQUksQ0FBQ1osQ0FBQUEsSUFBS0EsRUFBRVQsU0FBUyxLQUFLbUIsU0FBUyxPQUFPbEI7d0JBQ25ELE9BQU87NEJBQUNYLEtBQUtTLElBQUk7K0JBQUtFO3lCQUFLO29CQUMvQjtnQkFDSjtZQUNKO1lBRUEsTUFBTVgsT0FBTyxNQUFNcEIsNkNBQU9BLENBQUMwQyxXQUFXLENBQUNHLFlBQVlJO1lBRW5ELElBQUk3QixLQUFLRSxNQUFNLEtBQUssV0FBVztnQkFDM0IsTUFBTThCLFlBQVk7b0JBQ2RMLE1BQU07b0JBQ05DLFNBQVM1QixLQUFLaUMsYUFBYSxJQUFJO29CQUMvQkMsaUJBQWlCbEMsS0FBS2tDLGVBQWUsSUFBSSxFQUFFO2dCQUMvQztnQkFDQW5ELFlBQVk0QixDQUFBQSxPQUFROzJCQUFJQTt3QkFBTXFCO3FCQUFVO1lBQzVDLE9BQU87Z0JBQ0gzQyxTQUFTVyxLQUFLbUMsTUFBTSxJQUFJO2dCQUN4QnBELFlBQVk0QixDQUFBQSxPQUFROzJCQUFJQTt3QkFBTTs0QkFDMUJnQixNQUFNOzRCQUNOQyxTQUFTO3dCQUNiO3FCQUFFO1lBQ047UUFDSixFQUFFLE9BQU94QixLQUFLO1lBQ1ZmLFNBQVNlLElBQUlnQyxPQUFPLElBQUk7WUFDeEJyRCxZQUFZNEIsQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU07d0JBQzFCZ0IsTUFBTTt3QkFDTkMsU0FBU3hCLElBQUlnQyxPQUFPLElBQUk7b0JBQzVCO2lCQUFFO1lBQ0YvQixRQUFRakIsS0FBSyxDQUFDLGVBQWVnQjtRQUNqQyxTQUFVO1lBQ05uQixXQUFXO1FBQ2Y7SUFDSjtJQUVBLE1BQU1vRCxZQUFZO1FBQ2R0RCxZQUFZLEVBQUU7UUFDZE0sU0FBUztJQUNiO0lBRUEsMkRBQTJEO0lBRzNELE9BQU87UUFDSFA7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUk7UUFDQUY7UUFDQWdDO1FBQ0FlO1FBQ0EvQjtRQUNBTTtRQUNBRztRQUNBSztRQUNBMUI7SUFDSjtBQUNKLEVBQUU7R0E5S1diIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNoYXQuanM/MDY1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGNoYXRBcGkgfSBmcm9tICdAL2xpYi9hcGknO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUNoYXQgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtoaXN0b3J5TG9hZGluZywgc2V0SGlzdG9yeUxvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgICBjb25zdCBbY3VycmVudENoYXRJZCwgc2V0Q3VycmVudENoYXRJZF0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtjaGF0TGlzdCwgc2V0Q2hhdExpc3RdID0gdXNlU3RhdGUoW10pO1xyXG4gICAgY29uc3QgbWVzc2FnZXNFbmRSZWYgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4gICAgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSAoKSA9PiB7XHJcbiAgICAgICAgbWVzc2FnZXNFbmRSZWYuY3VycmVudD8uc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2Nyb2xsVG9Cb3R0b20oKTtcclxuICAgIH0sIFttZXNzYWdlcywgbG9hZGluZ10pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbG9hZENoYXRIaXN0b3J5KCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gQXV0by1yZXN0b3JlIHJlbW92ZWQgdG8gZm9yY2UgbmV3IHNlc3Npb24gb24gcmVmcmVzaFxyXG5cclxuXHJcbiAgICBjb25zdCBsb2FkQ2hhdEhpc3RvcnkgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNoYXRBcGkuZ2V0SGlzdG9yeSgpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgICAgICAgICAgc2V0Q2hhdExpc3QoZGF0YS5jaGF0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgY2hhdCBoaXN0b3J5OicsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBzdGFydE5ld0NoYXQgPSBhc3luYyAodGl0bGUgPSBcIk5ldyBDaGF0XCIpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2hhdEFwaS5jcmVhdGVDaGF0KHRpdGxlKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDaGF0SWQoZGF0YS5jaGF0LlRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhbXSk7XHJcbiAgICAgICAgICAgICAgICBzZXRDaGF0TGlzdChwcmV2ID0+IFtkYXRhLmNoYXQsIC4uLnByZXZdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBuZXcgY2hhdCcpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgbG9hZENoYXQgPSBhc3luYyAodGltZXN0YW1wKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc2V0SGlzdG9yeUxvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRDaGF0SWQodGltZXN0YW1wKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNoYXRBcGkuZ2V0Q2hhdE1lc3NhZ2VzKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhkYXRhLmNoYXQubWVzc2FnZXMgfHwgW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjaGF0IG1lc3NhZ2VzJyk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgc2V0SGlzdG9yeUxvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZGVsZXRlQ2hhdCA9IGFzeW5jICh0aW1lc3RhbXApID0+IHtcclxuICAgICAgICBpZiAoIXdpbmRvdy5jb25maXJtKFwiRGVsZXRlIHRoaXMgc3BlY2lmaWMgY2hhdCBzZXNzaW9uP1wiKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBjaGF0QXBpLmRlbGV0ZUNoYXQodGltZXN0YW1wKTtcclxuICAgICAgICAgICAgc2V0Q2hhdExpc3QocHJldiA9PiBwcmV2LmZpbHRlcihjID0+IGMuVGltZXN0YW1wICE9PSB0aW1lc3RhbXApKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGF0SWQgPT09IHRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudENoYXRJZChudWxsKTtcclxuICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGNoYXQ6JywgZXJyKTtcclxuICAgICAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgY2hhdCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY2xlYXJBbGxIaXN0b3J5ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmICghd2luZG93LmNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHlvdXIgZW50aXJlIGNoYXQgaGlzdG9yeT8gVGhpcyBjYW5ub3QgYmUgdW5kb25lLlwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNoYXRBcGkuZGVsZXRlQWxsSGlzdG9yeSgpO1xyXG4gICAgICAgICAgICBzZXRDaGF0TGlzdChbXSk7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRDaGF0SWQobnVsbCk7XHJcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKFtdKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsZWFyIEFMTCBoaXN0b3J5OicsIGVycik7XHJcbiAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gY2xlYXIgZW50aXJlIGhpc3RvcnknKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKHByb21wdCkgPT4ge1xyXG4gICAgICAgIGlmICghcHJvbXB0LnRyaW0oKSB8fCBsb2FkaW5nKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZXJQcm9tcHQgPSBwcm9tcHQudHJpbSgpO1xyXG4gICAgICAgIHNldEVycm9yKCcnKTtcclxuXHJcbiAgICAgICAgY29uc3QgbmV3VXNlck1lc3NhZ2UgPSB7IHJvbGU6ICd1c2VyJywgY29udGVudDogdXNlclByb21wdCB9O1xyXG4gICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIG5ld1VzZXJNZXNzYWdlXSk7XHJcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IGNoYXRJZCA9IGN1cnJlbnRDaGF0SWQ7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGFjdGl2ZSBjaGF0LCBjcmVhdGUgb25lIGF1dG9tYXRpY2FsbHlcclxuICAgICAgICAgICAgaWYgKCFjaGF0SWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjaGF0QXBpLmNyZWF0ZUNoYXQodXNlclByb21wdC5zdWJzdHJpbmcoMCwgMzApICsgXCIuLi5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXRJZCA9IGRhdGEuY2hhdC5UaW1lc3RhbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENoYXRJZChjaGF0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldENoYXRMaXN0KHByZXYgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBkdXBsaWNhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2LnNvbWUoYyA9PiBjLlRpbWVzdGFtcCA9PT0gY2hhdElkKSkgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbZGF0YS5jaGF0LCAuLi5wcmV2XTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNoYXRBcGkuc2VuZE1lc3NhZ2UodXNlclByb21wdCwgY2hhdElkKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhaU1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZGF0YS5jaGF0X3Jlc3BvbnNlIHx8IFwiSSd2ZSBhbmFseXplZCB5b3VyIHJlcXVpcmVtZW50cyBhbmQgZm91bmQgc29tZSBncmVhdCBvcHRpb25zIGZvciB5b3UuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zOiBkYXRhLnJlY29tbWVuZGF0aW9ucyB8fCBbXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIGFpTWVzc2FnZV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoZGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBnZW5lcmF0ZSByZWNvbW1lbmRhdGlvbnMnKTtcclxuICAgICAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcclxuICAgICAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnU29ycnksIEkgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgcHJvY2Vzc2luZyB5b3VyIHJlcXVlc3QuIFBsZWFzZSB0cnkgYWdhaW4uJ1xyXG4gICAgICAgICAgICAgICAgfV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8ICdFcnJvciBjb25uZWN0aW5nIHRvIGJhY2tlbmQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XHJcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcclxuICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogZXJyLm1lc3NhZ2UgfHwgJ0Nvbm5lY3Rpb24gZmFpbGVkJ1xyXG4gICAgICAgICAgICB9XSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NoYXQgRXJyb3I6JywgZXJyKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNsZWFyQ2hhdCA9ICgpID0+IHtcclxuICAgICAgICBzZXRNZXNzYWdlcyhbXSk7XHJcbiAgICAgICAgc2V0RXJyb3IoJycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQZXJzaXN0ZW5jZSByZW1vdmVkIHRvIGVuc3VyZSByZWZyZXNoIHN0YXJ0cyBuZXcgc2Vzc2lvblxyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1lc3NhZ2VzLFxyXG4gICAgICAgIGxvYWRpbmcsXHJcbiAgICAgICAgaGlzdG9yeUxvYWRpbmcsXHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgY2hhdExpc3QsXHJcbiAgICAgICAgY3VycmVudENoYXRJZCxcclxuICAgICAgICBzZW5kTWVzc2FnZSxcclxuICAgICAgICBjbGVhckNoYXQsXHJcbiAgICAgICAgc3RhcnROZXdDaGF0LFxyXG4gICAgICAgIGxvYWRDaGF0LFxyXG4gICAgICAgIGRlbGV0ZUNoYXQsXHJcbiAgICAgICAgY2xlYXJBbGxIaXN0b3J5LFxyXG4gICAgICAgIG1lc3NhZ2VzRW5kUmVmXHJcbiAgICB9O1xyXG59O1xyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjaGF0QXBpIiwidXNlQ2hhdCIsIm1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImhpc3RvcnlMb2FkaW5nIiwic2V0SGlzdG9yeUxvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiY3VycmVudENoYXRJZCIsInNldEN1cnJlbnRDaGF0SWQiLCJjaGF0TGlzdCIsInNldENoYXRMaXN0IiwibWVzc2FnZXNFbmRSZWYiLCJzY3JvbGxUb0JvdHRvbSIsImN1cnJlbnQiLCJzY3JvbGxJbnRvVmlldyIsImJlaGF2aW9yIiwibG9hZENoYXRIaXN0b3J5IiwiZGF0YSIsImdldEhpc3RvcnkiLCJzdGF0dXMiLCJjaGF0cyIsImVyciIsImNvbnNvbGUiLCJzdGFydE5ld0NoYXQiLCJ0aXRsZSIsImNyZWF0ZUNoYXQiLCJjaGF0IiwiVGltZXN0YW1wIiwicHJldiIsImxvYWRDaGF0IiwidGltZXN0YW1wIiwiZ2V0Q2hhdE1lc3NhZ2VzIiwiZGVsZXRlQ2hhdCIsIndpbmRvdyIsImNvbmZpcm0iLCJmaWx0ZXIiLCJjIiwiY2xlYXJBbGxIaXN0b3J5IiwiZGVsZXRlQWxsSGlzdG9yeSIsInNlbmRNZXNzYWdlIiwicHJvbXB0IiwidHJpbSIsInVzZXJQcm9tcHQiLCJuZXdVc2VyTWVzc2FnZSIsInJvbGUiLCJjb250ZW50IiwiY2hhdElkIiwic3Vic3RyaW5nIiwic29tZSIsImFpTWVzc2FnZSIsImNoYXRfcmVzcG9uc2UiLCJyZWNvbW1lbmRhdGlvbnMiLCJkZXRhaWwiLCJtZXNzYWdlIiwiY2xlYXJDaGF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChat.js\n"));

/***/ })

});