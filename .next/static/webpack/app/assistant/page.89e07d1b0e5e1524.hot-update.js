"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/assistant/page",{

/***/ "(app-pages-browser)/./hooks/useChat.js":
/*!**************************!*\
  !*** ./hooks/useChat.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.js\");\n/* __next_internal_client_entry_do_not_use__ useChat auto */ var _s = $RefreshSig$();\n\n\nconst useChat = ()=>{\n    _s();\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [historyLoading, setHistoryLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [currentChatId, setCurrentChatId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [chatList, setChatList] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const messagesEndRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const scrollToBottom = ()=>{\n        var _messagesEndRef_current;\n        (_messagesEndRef_current = messagesEndRef.current) === null || _messagesEndRef_current === void 0 ? void 0 : _messagesEndRef_current.scrollIntoView({\n            behavior: \"smooth\"\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        scrollToBottom();\n    }, [\n        messages,\n        loading\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        loadChatHistory();\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Restore last open chat/messages when returning to assistant\n        if (false) {}\n        const savedChatId = sessionStorage.getItem(\"currentChatId\");\n        const savedMessages = sessionStorage.getItem(\"currentChatMessages\");\n        if (savedChatId) {\n            setCurrentChatId(savedChatId);\n            if (savedMessages) {\n                try {\n                    setMessages(JSON.parse(savedMessages));\n                } catch (e) {\n                // ignore parse errors\n                }\n            } else {\n                loadChat(savedChatId);\n            }\n        }\n    }, []);\n    const loadChatHistory = async ()=>{\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.getHistory();\n            if (data.status === \"success\") {\n                setChatList(data.chats);\n            }\n        } catch (err) {\n            console.error(\"Failed to load chat history:\", err);\n        }\n    };\n    const startNewChat = async function() {\n        let title = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"New Chat\";\n        try {\n            setLoading(true);\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.createChat(title);\n            if (data.status === \"success\") {\n                setCurrentChatId(data.chat.Timestamp);\n                setMessages([]);\n                setChatList((prev)=>[\n                        data.chat,\n                        ...prev\n                    ]);\n            }\n        } catch (err) {\n            setError(\"Failed to create new chat\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const loadChat = async (timestamp)=>{\n        try {\n            setHistoryLoading(true);\n            setCurrentChatId(timestamp);\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.getChatMessages(timestamp);\n            if (data.status === \"success\") {\n                setMessages(data.chat.messages || []);\n            }\n        } catch (err) {\n            setError(\"Failed to load chat messages\");\n        } finally{\n            setHistoryLoading(false);\n        }\n    };\n    const deleteChat = async (timestamp)=>{\n        if (!window.confirm(\"Delete this specific chat session?\")) return;\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.deleteChat(timestamp);\n            setChatList((prev)=>prev.filter((c)=>c.Timestamp !== timestamp));\n            if (currentChatId === timestamp) {\n                setCurrentChatId(null);\n                setMessages([]);\n            }\n        } catch (err) {\n            console.error(\"Failed to delete chat:\", err);\n            setError(\"Failed to delete chat\");\n        }\n    };\n    const clearAllHistory = async ()=>{\n        if (!window.confirm(\"Are you sure you want to delete your entire chat history? This cannot be undone.\")) {\n            return;\n        }\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.deleteAllHistory();\n            setChatList([]);\n            setCurrentChatId(null);\n            setMessages([]);\n        } catch (err) {\n            console.error(\"Failed to clear ALL history:\", err);\n            setError(\"Failed to clear entire history\");\n        }\n    };\n    const sendMessage = async (prompt)=>{\n        if (!prompt.trim() || loading) return;\n        const userPrompt = prompt.trim();\n        setError(\"\");\n        const newUserMessage = {\n            role: \"user\",\n            content: userPrompt\n        };\n        setMessages((prev)=>[\n                ...prev,\n                newUserMessage\n            ]);\n        setLoading(true);\n        try {\n            let chatId = currentChatId;\n            // If no active chat, create one automatically\n            if (!chatId) {\n                const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.createChat(userPrompt.substring(0, 30) + \"...\");\n                if (data.status === \"success\") {\n                    chatId = data.chat.Timestamp;\n                    setCurrentChatId(chatId);\n                    setChatList((prev)=>{\n                        // Avoid duplicates\n                        if (prev.some((c)=>c.Timestamp === chatId)) return prev;\n                        return [\n                            data.chat,\n                            ...prev\n                        ];\n                    });\n                }\n            }\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.chatApi.sendMessage(userPrompt, chatId);\n            if (data.status === \"success\") {\n                const aiMessage = {\n                    role: \"assistant\",\n                    content: data.chat_response || \"I've analyzed your requirements and found some great options for you.\",\n                    recommendations: data.recommendations || []\n                };\n                setMessages((prev)=>[\n                        ...prev,\n                        aiMessage\n                    ]);\n            } else {\n                setError(data.detail || \"Failed to generate recommendations\");\n                setMessages((prev)=>[\n                        ...prev,\n                        {\n                            role: \"assistant\",\n                            content: \"Sorry, I encountered an error while processing your request. Please try again.\"\n                        }\n                    ]);\n            }\n        } catch (err) {\n            setError(err.message || \"Error connecting to backend. Please try again.\");\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        role: \"assistant\",\n                        content: err.message || \"Connection failed\"\n                    }\n                ]);\n            console.error(\"Chat Error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const clearChat = ()=>{\n        setMessages([]);\n        setError(\"\");\n    };\n    // Persistence removed to ensure refresh starts new session\n    return {\n        messages,\n        loading,\n        historyLoading,\n        error,\n        chatList,\n        currentChatId,\n        sendMessage,\n        clearChat,\n        startNewChat,\n        loadChat,\n        deleteChat,\n        clearAllHistory,\n        messagesEndRef\n    };\n};\n_s(useChat, \"32kO/9Ouc8X6Hlqv+ooabcfh66U=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FzQztRQUNBZTtRQUNBOUI7UUFDQVA7UUFDQWU7UUFDQUs7UUFDQWhDO0lBQ0o7QUFDSixFQUFFO0dBOUxXYiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VDaGF0LmpzPzA2NTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBjaGF0QXBpIH0gZnJvbSAnQC9saWIvYXBpJztcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VDaGF0ID0gKCkgPT4ge1xyXG4gICAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaGlzdG9yeUxvYWRpbmcsIHNldEhpc3RvcnlMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUoJycpO1xyXG4gICAgY29uc3QgW2N1cnJlbnRDaGF0SWQsIHNldEN1cnJlbnRDaGF0SWRdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICBjb25zdCBbY2hhdExpc3QsIHNldENoYXRMaXN0XSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIGNvbnN0IG1lc3NhZ2VzRW5kUmVmID0gdXNlUmVmKG51bGwpO1xyXG5cclxuICAgIGNvbnN0IHNjcm9sbFRvQm90dG9tID0gKCkgPT4ge1xyXG4gICAgICAgIG1lc3NhZ2VzRW5kUmVmLmN1cnJlbnQ/LnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNjcm9sbFRvQm90dG9tKCk7XHJcbiAgICB9LCBbbWVzc2FnZXMsIGxvYWRpbmddKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxvYWRDaGF0SGlzdG9yeSgpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgLy8gUmVzdG9yZSBsYXN0IG9wZW4gY2hhdC9tZXNzYWdlcyB3aGVuIHJldHVybmluZyB0byBhc3Npc3RhbnRcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuICAgICAgICBjb25zdCBzYXZlZENoYXRJZCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2N1cnJlbnRDaGF0SWQnKTtcclxuICAgICAgICBjb25zdCBzYXZlZE1lc3NhZ2VzID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnY3VycmVudENoYXRNZXNzYWdlcycpO1xyXG4gICAgICAgIGlmIChzYXZlZENoYXRJZCkge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2hhdElkKHNhdmVkQ2hhdElkKTtcclxuICAgICAgICAgICAgaWYgKHNhdmVkTWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZXMoSlNPTi5wYXJzZShzYXZlZE1lc3NhZ2VzKSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgcGFyc2UgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkQ2hhdChzYXZlZENoYXRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgbG9hZENoYXRIaXN0b3J5ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjaGF0QXBpLmdldEhpc3RvcnkoKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcclxuICAgICAgICAgICAgICAgIHNldENoYXRMaXN0KGRhdGEuY2hhdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNoYXQgaGlzdG9yeTonLCBlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgc3RhcnROZXdDaGF0ID0gYXN5bmMgKHRpdGxlID0gXCJOZXcgQ2hhdFwiKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNoYXRBcGkuY3JlYXRlQ2hhdCh0aXRsZSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q2hhdElkKGRhdGEuY2hhdC5UaW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgc2V0TWVzc2FnZXMoW10pO1xyXG4gICAgICAgICAgICAgICAgc2V0Q2hhdExpc3QocHJldiA9PiBbZGF0YS5jaGF0LCAuLi5wcmV2XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgbmV3IGNoYXQnKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGxvYWRDaGF0ID0gYXN5bmMgKHRpbWVzdGFtcCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNldEhpc3RvcnlMb2FkaW5nKHRydWUpO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2hhdElkKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjaGF0QXBpLmdldENoYXRNZXNzYWdlcyh0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgICAgICAgICAgc2V0TWVzc2FnZXMoZGF0YS5jaGF0Lm1lc3NhZ2VzIHx8IFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGxvYWQgY2hhdCBtZXNzYWdlcycpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHNldEhpc3RvcnlMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGRlbGV0ZUNoYXQgPSBhc3luYyAodGltZXN0YW1wKSA9PiB7XHJcbiAgICAgICAgaWYgKCF3aW5kb3cuY29uZmlybShcIkRlbGV0ZSB0aGlzIHNwZWNpZmljIGNoYXQgc2Vzc2lvbj9cIikpIHJldHVybjtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgY2hhdEFwaS5kZWxldGVDaGF0KHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIHNldENoYXRMaXN0KHByZXYgPT4gcHJldi5maWx0ZXIoYyA9PiBjLlRpbWVzdGFtcCAhPT0gdGltZXN0YW1wKSk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhdElkID09PSB0aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDaGF0SWQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBjaGF0OicsIGVycik7XHJcbiAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGNoYXQnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNsZWFyQWxsSGlzdG9yeSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoIXdpbmRvdy5jb25maXJtKFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB5b3VyIGVudGlyZSBjaGF0IGhpc3Rvcnk/IFRoaXMgY2Fubm90IGJlIHVuZG9uZS5cIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBjaGF0QXBpLmRlbGV0ZUFsbEhpc3RvcnkoKTtcclxuICAgICAgICAgICAgc2V0Q2hhdExpc3QoW10pO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50Q2hhdElkKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhbXSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhciBBTEwgaGlzdG9yeTonLCBlcnIpO1xyXG4gICAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGNsZWFyIGVudGlyZSBoaXN0b3J5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jIChwcm9tcHQpID0+IHtcclxuICAgICAgICBpZiAoIXByb21wdC50cmltKCkgfHwgbG9hZGluZykgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VyUHJvbXB0ID0gcHJvbXB0LnRyaW0oKTtcclxuICAgICAgICBzZXRFcnJvcignJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld1VzZXJNZXNzYWdlID0geyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IHVzZXJQcm9tcHQgfTtcclxuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdVc2VyTWVzc2FnZV0pO1xyXG4gICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBjaGF0SWQgPSBjdXJyZW50Q2hhdElkO1xyXG4gICAgICAgICAgICAvLyBJZiBubyBhY3RpdmUgY2hhdCwgY3JlYXRlIG9uZSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICAgIGlmICghY2hhdElkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2hhdEFwaS5jcmVhdGVDaGF0KHVzZXJQcm9tcHQuc3Vic3RyaW5nKDAsIDMwKSArIFwiLi4uXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGF0SWQgPSBkYXRhLmNoYXQuVGltZXN0YW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDaGF0SWQoY2hhdElkKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDaGF0TGlzdChwcmV2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgZHVwbGljYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5zb21lKGMgPT4gYy5UaW1lc3RhbXAgPT09IGNoYXRJZCkpIHJldHVybiBwcmV2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2RhdGEuY2hhdCwgLi4ucHJldl07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjaGF0QXBpLnNlbmRNZXNzYWdlKHVzZXJQcm9tcHQsIGNoYXRJZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWlNZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGRhdGEuY2hhdF9yZXNwb25zZSB8fCBcIkkndmUgYW5hbHl6ZWQgeW91ciByZXF1aXJlbWVudHMgYW5kIGZvdW5kIHNvbWUgZ3JlYXQgb3B0aW9ucyBmb3IgeW91LlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogZGF0YS5yZWNvbW1lbmRhdGlvbnMgfHwgW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBhaU1lc3NhZ2VdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldEVycm9yKGRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZ2VuZXJhdGUgcmVjb21tZW5kYXRpb25zJyk7XHJcbiAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1NvcnJ5LCBJIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHByb2Nlc3NpbmcgeW91ciByZXF1ZXN0LiBQbGVhc2UgdHJ5IGFnYWluLidcclxuICAgICAgICAgICAgICAgIH1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCAnRXJyb3IgY29ubmVjdGluZyB0byBiYWNrZW5kLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xyXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XHJcbiAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVyci5tZXNzYWdlIHx8ICdDb25uZWN0aW9uIGZhaWxlZCdcclxuICAgICAgICAgICAgfV0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDaGF0IEVycm9yOicsIGVycik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBjbGVhckNoYXQgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0TWVzc2FnZXMoW10pO1xyXG4gICAgICAgIHNldEVycm9yKCcnKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGVyc2lzdGVuY2UgcmVtb3ZlZCB0byBlbnN1cmUgcmVmcmVzaCBzdGFydHMgbmV3IHNlc3Npb25cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtZXNzYWdlcyxcclxuICAgICAgICBsb2FkaW5nLFxyXG4gICAgICAgIGhpc3RvcnlMb2FkaW5nLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIGNoYXRMaXN0LFxyXG4gICAgICAgIGN1cnJlbnRDaGF0SWQsXHJcbiAgICAgICAgc2VuZE1lc3NhZ2UsXHJcbiAgICAgICAgY2xlYXJDaGF0LFxyXG4gICAgICAgIHN0YXJ0TmV3Q2hhdCxcclxuICAgICAgICBsb2FkQ2hhdCxcclxuICAgICAgICBkZWxldGVDaGF0LFxyXG4gICAgICAgIGNsZWFyQWxsSGlzdG9yeSxcclxuICAgICAgICBtZXNzYWdlc0VuZFJlZlxyXG4gICAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY2hhdEFwaSIsInVzZUNoYXQiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJoaXN0b3J5TG9hZGluZyIsInNldEhpc3RvcnlMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImN1cnJlbnRDaGF0SWQiLCJzZXRDdXJyZW50Q2hhdElkIiwiY2hhdExpc3QiLCJzZXRDaGF0TGlzdCIsIm1lc3NhZ2VzRW5kUmVmIiwic2Nyb2xsVG9Cb3R0b20iLCJjdXJyZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvciIsImxvYWRDaGF0SGlzdG9yeSIsInNhdmVkQ2hhdElkIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwic2F2ZWRNZXNzYWdlcyIsIkpTT04iLCJwYXJzZSIsImxvYWRDaGF0IiwiZGF0YSIsImdldEhpc3RvcnkiLCJzdGF0dXMiLCJjaGF0cyIsImVyciIsImNvbnNvbGUiLCJzdGFydE5ld0NoYXQiLCJ0aXRsZSIsImNyZWF0ZUNoYXQiLCJjaGF0IiwiVGltZXN0YW1wIiwicHJldiIsInRpbWVzdGFtcCIsImdldENoYXRNZXNzYWdlcyIsImRlbGV0ZUNoYXQiLCJ3aW5kb3ciLCJjb25maXJtIiwiZmlsdGVyIiwiYyIsImNsZWFyQWxsSGlzdG9yeSIsImRlbGV0ZUFsbEhpc3RvcnkiLCJzZW5kTWVzc2FnZSIsInByb21wdCIsInRyaW0iLCJ1c2VyUHJvbXB0IiwibmV3VXNlck1lc3NhZ2UiLCJyb2xlIiwiY29udGVudCIsImNoYXRJZCIsInN1YnN0cmluZyIsInNvbWUiLCJhaU1lc3NhZ2UiLCJjaGF0X3Jlc3BvbnNlIiwicmVjb21tZW5kYXRpb25zIiwiZGV0YWlsIiwibWVzc2FnZSIsImNsZWFyQ2hhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChat.js\n"));

/***/ })

});